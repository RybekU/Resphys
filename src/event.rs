use super::object::{Collider, ColliderHandle, ColliderState};

/// Event generated by the physics engine.  
/// In case of an overlap between a solid body and sensor the solid body is guaranteed to be the first handle.
#[derive(Debug, Clone, Copy)]
pub enum PhysicsEvent<T> {
    OverlapStarted(ColliderHandle, ColliderHandle, T, T),
    OverlapEnded(ColliderHandle, ColliderHandle, T, T),
    CollisionStarted(ColliderHandle, ColliderHandle, T, T),
    CollisionEnded(ColliderHandle, ColliderHandle, T, T),
}

impl<T: Copy> PhysicsEvent<T> {
    pub fn new(
        h1: usize,
        collider1: &Collider<T>,
        h2: usize,
        collider2: &Collider<T>,
    ) -> PhysicsEvent<T> {
        use ColliderState::*;
        match (&collider1.state, &collider2.state) {
            (Solid, Solid) => PhysicsEvent::CollisionStarted(
                ColliderHandle(h1),
                ColliderHandle(h2),
                collider1.user_tag,
                collider2.user_tag,
            ),
            (Solid, Sensor) => PhysicsEvent::OverlapStarted(
                ColliderHandle(h1),
                ColliderHandle(h2),
                collider1.user_tag,
                collider2.user_tag,
            ),
            (Sensor, Solid) => PhysicsEvent::OverlapStarted(
                ColliderHandle(h2),
                ColliderHandle(h1),
                collider2.user_tag,
                collider1.user_tag,
            ),
            (Sensor, Sensor) => PhysicsEvent::OverlapStarted(
                ColliderHandle(h1),
                ColliderHandle(h2),
                collider1.user_tag,
                collider2.user_tag,
            ),
        }
    }
    // changes started events into ended
    pub(crate) fn into_finished(self) -> PhysicsEvent<T> {
        match self {
            Self::OverlapStarted(h1, h2, t1, t2) => Self::OverlapEnded(h1, h2, t1, t2),
            Self::CollisionStarted(h1, h2, t1, t2) => Self::CollisionEnded(h1, h2, t1, t2),
            _ => self,
        }
    }
}
